/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package algorithm.complexity;

import algorithm.complexity.search.LinearSearch;
import algorithm.complexity.search.BinarySearch;
import algorithm.complexity.search.SearchExecutor;
import algorithm.complexity.sort.BubbleSort;
import algorithm.complexity.sort.QuickSort;
import algorithm.complexity.sort.SortExecutor;

import java.util.Arrays;
import java.util.Random;

public class App {
    public static void main(String[] args) throws Exception {
        // bigger the algorithm
        // more time and space it will consume

        int searchArraySize = 1000000;
        int sortArraySize = 1000;
        int[] searchSample = generateSample(searchArraySize);
        int[] sortSample = generateSample(sortArraySize);

        System.out.println("\n\nUsing sample with " + searchArraySize + " positions for search.");
        System.out.println("\n\nUsing sample with " + sortArraySize + " positions for sort.");
        System.out.println("Running algorithms...");

        int value = 100544;

        // ----------------------------------------
        // O(n)
        // ----------------------------------------

        new SearchExecutor(new LinearSearch()).search(value, searchSample);

        // ----------------------------------------
        // O(n^2)
        // ----------------------------------------

        new SortExecutor(new BubbleSort()).sort(sortSample);

        // ----------------------------------------
        // O(log n)
        // ----------------------------------------

        // The key aspect here is that the array is already sorted
        int[] clonedArray = searchSample.clone();
        Arrays.sort(clonedArray);
        // binary search keeps splitting the the search in 2 (left and right)
        new SearchExecutor(new BinarySearch()).search(value, clonedArray);

        // ----------------------------------------
        // O(n log n)
        // ----------------------------------------

        /*
        * comparisons = log n!
        * comparisons = log n + log(n-1) + ... + log (1)
        * comparisons = n log n
        * */

        // less time shifting numbers.. more efficiently

        new SortExecutor(new QuickSort()).sort(sortSample);

    }

    private static int[] generateSample(int sizeForSearch) {
        int[] arrayForSearch = generateArray(sizeForSearch);
        shuffle(arrayForSearch);
        return arrayForSearch;
    }

    private static void shuffle(int[] array) {
        final Random random = new Random();
        for (int i = 0; i < array.length; i++) {
            int index = random.nextInt(i + 1);
            int v = array[index];
            array[index] = array[i];
            array[i] = v;
        }
    }

    private static int[] generateArray(int size) {
        int[] array = new int[size];
        for (int i = 0; i < array.length; i++) {
            array[i] = i+1;
        }
        return array;
    }
}
